——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

一、树
    <1> 基本概念
            · 根节点、分支节点、叶子结点、子树、空树、非空树……
        1. 结点之间的关系描述
            · 祖先结点
            · 子孙结点
            · 双亲节点(父结点)
            · 孩子结点
            · 兄弟结点
            · 堂兄弟结点
            · 结点之间的路径：只能从上往下
            · 路径长度
        2. 结点、树的属性描述
            · 结点的层次(深度)--从上往下数
            · 结点的高度--------从下往上数
            · 树的高度(深度)----总共有多少层
            · 结点的度----------该结点有几个孩子(分支)
            · 树的度------------各结点的度的最大值
            · 有序树------------结点的各子树从左至右是有次序的、不能交换
            · 无序树------------同上无次序
        3. 树和森林
            · 森林--------------m(m>=0)颗互不相交的树组成的

    <2> 树的常考性质
        · 结点数=总度数+1
        · 度为m的树和m叉树的区别
        · 度为m的树第i层至多有m^(i-1)个结点
        · 高度为h的m叉树最多有(m^h-1)/(m-1)个结点(最少有多少?)
        · 有n个结点的m叉树的最小高度为[logm(n(m-1)+1)] (上取整)
    
二、二叉树
    ① 空树
    ② 由一个根节点和两个互不相交的根的左子树和右子树组成，左右子树又分别是一颗二叉树
    特点----每个节点至多只有两棵子树、左右子树不能颠倒(二叉树是有序树)
    
    1. 几个特殊的二叉树
        · 满二叉树-------------------一颗高度为h、且含有2^h-1个结点的二叉树
            --只有最后一层又叶子结点
            --不存在度为1的结点
            --按层序从1开始编号，结点i的左孩子为2i、右孩子为2i+1，结点i的父节点为i/2(下取整)
            
        · 完全二叉树-----------------当且仅当其每个节点都与高度为h的满二叉树中编号为1~n的结点一一对应
            --只有最后两层可能有叶子结点
            --最多只有一个度为1的结点
            --同上③
            --若有n个结点、i<=n/2(下取整)为分支节点，i>n/2(下取整)为叶子结点
            --若有一个度为1的结点，他的孩子一定是左孩子
        
        · 二叉排序树------------------具有以下性质的二叉树
            ① 左子树上所有结点的关键字均小于根节点的关键字
            ② 右子树上所有结点的关键字均大于根节点的关键字
            ③ 左子树和右子树又各是一颗二叉排序树

        · 平衡二叉树------------------树上任一结点的左子树和右子树的深度之差不超过1

    2. 二叉树的常考性质
        · n0 = n2 + n1 // 叶子结点的个数比二分支结点的个数多1
            ① n = n0 + n1 + n2
            ② n = n1 + 2*n2 + 1
        · 二叉树的第i层最多有2^(i-1)个结点
        · 高度为h的二叉树至多有2^h -1个结点
        · n个结点的完全二叉树的高度为log2(n+1) (上取整)
        · 对于完全二叉树，可以由结点数n推出度为0/1/2的结点的个数
            --最多只有一个度为1的结点：n0 = 0 或 1
            --n0 = n2 + 1 -> n0 + n2 一定是奇数
            --若完全二叉树有2k(偶数)个结点,则必有n1=1、n0=k、n2=k-1
            --若完全二叉树有2k+1(奇数)个结点,则必有n1=0、n0=k、n2=k-1

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

二、二叉树的存储结构

    <1> 二叉树的顺序存储

        #define MaxSize 100
        struct TreeNode {
            ElemType value; // 节点中的数据元素
            bool isEmpty;   // 结点是否为空
        };

        TreeNode t[MaxSize];// 定义一个长度为MaxSize的数组t，按照从上至下从左至右的顺序依次储存完全二叉树中的各个结点

        for (int i=0; i<MaxSize; i++)
            t[i].isEmpty = true;//初始化所有结点为空
        
        · 几个重要的基本操作(完全二叉树)
            · i的左孩子--2i
            · i的右孩子--2i+1
            · i的父结点--[i/2] (下取整)
            · i所在的层次--[log2(n)] (下取整) + 1
            · 判断i是否有左孩子?--2i<=n?
            · 判断i是否有右孩子?--2i+1<=n?
            · 判断i是否是叶子/分支结点?--i>[n/2] (下取整)
        最坏情况--高度为h且只有h个结点的单支树，也至少需要2^h-1个存储单元
    
    <2> 二叉树的链式存储
     可以快速找到左右孩子，但不易找到父结点[可以在结构体中定义一个父结点指针(三叉链表)]

        struct ElemType { //数据域
            int value;
        };

        typedef struct BiTNode {
            ElemType data;      //数据域
            struct BiTNode *lchild, *rchile; //左右孩子指针
        } BiTNode, BiTree;

        // n个结点则有2n个指针，而一共有n-1个结点头上会连一个指针
        // 所以n个结点的二叉链表共有n+1个空链域-->构造线索二叉树

            //定义一颗空树
            BiTree root = NULL;
            
            //插入根节点
            root = (BiTree) malloc (sizeof(BiTNode));
            root -> data = {1};
            root -> lchild = NULL;
            root -> rchile = NULL;
            //插入新节点…………

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

三、二叉树的遍历

    <1> 先序遍历--根左右--前缀表达式//叶子结点都是计算数，分支结点都是运算符
    void PreOrder (BiTree T) {
        if(T) {
            visit (T);                  //访问根节点
            PreOrder (T -> lchild);     //递归访问左子树
            PreOrder (T -> rchild);     //递归访问右子树
        }
    }
    <2> 中序遍历--左根右--中缀表达式(需要加界限符)
    void InOrder (BiTree T) {
        if(T) {
            InOrder (T -> lchild);
            visit (T);
            InOrder (T -> rchild);
        }
    }
    <3> 后序遍历--左右根--后缀表达式
    void PostOrder (BiTree T) {
        if(T) {
            PostOrder (T -> lchild);
            PostOrder (T -> rchild);
            visit (T);
        }
    }
    <4> 层序遍历
        ①初始化一个辅助队列
        ②根结点入队
        ③若队列非空，则队头结点出队，访问该结点，并且将其左右孩子插入队尾(如果存在的话)
        ④重复③直至队列为空
        ----入队保存指针更省空间----
        void LevelOrder (BiTree T) {
            BiTree temp;
            LinkQueue Q;
            InitQueue (Q);                          //初始化辅助队列
            EnQueue (Q, T);                         //将根节点入队
            while(! IsEmpty(Q)) {                   //队列为空结束
                DeQueue (Q, temp);                  //根节点入队
                visit(temp);                        //visit根节点
                if(temp -> lchild)                  //左孩子非空则入队
                    EnQueue (Q, temp -> lchild);
                if(temp -> rchild)                  //右孩子非空则入队
                    EnQueue (Q, temp -> rchild);
            }
        }
        
    <5> 由遍历序列构造二叉树
        --可行的三种情况--：(单个序列不能唯一确定一颗二叉树)
            ①前序+中序遍历
            ②后序+中序遍历
            ③层序+中序遍历

        ----依靠：左右子树的序列在不同遍历序列中长度相同进行递归构造----
        前序遍历序列:   [ 根节点  [左子树的前序遍历]  [右子树的前序遍历] ]
        中序遍历序列:   [ [左子树的中序遍历]  根节点  [右子树的中序遍历] ]
        后序遍历序列:   [ [左子树的后序遍历]  [右子树的后序遍历]  根节点 ]
        层序遍历序列:   [ 根节点  左子树的根  右子树的根 …………  …………]
        //代码实现----Homework目录下

————————————————————————————————————————————————————————————————————————————————————————————————

四、特殊的二叉树
    <1> 线索二叉树--(问题：能否从某一个结点开始进行某种遍历?)
        · 问题：如何找到指定结点p在某种遍历中的前驱?
            ·思路://缺点--每找一次都得从根开始找一遍
             从根节点出发，重新进行一次某种遍历，指针q记录当前访问的结点，
             指针pre记录上一个被访问的结点。①当q==p时，pre为前驱 ②当pre==p时，q为后继
         --实现--
          BiTNode *p;                //p指向目标结点
          BiTNode *pre = NULL;       //指向当前访问结点的前驱
          BiTNode *final = NULL;     //用于记录最终结果
          
          void visit (BiTNode *q) {
             if(q == p)
                 final = pre;
             else
                 pre = q;
          }
          void InOrder_findPre (BiTree T) {
             if(T != NULL) {
                 InOrder (T -> lchild);
                 visit (T);
                 InOrder (T -> rchild);
             }
          }

        · 线索二叉树思路：n个结点的二叉树有n+1个空链域，可以用来记录前驱后继的信息

        · 线索二叉树的存储结构：
            typedef struct ThreadNode {
                ElemType data;
                struct ThreadNode *lchild, *rchild;
                int ltag,rtag;//左右线索标志,tag==0表示指针指向孩子，tag==1表示指针是“线索”
            } ThreadNode, *ThreadTree;

        · 二叉树的线索化(中序线索化代码)
            ThreadNode *pre = NULL;//全局变量指向当前结点的前驱
            
            void CreatInThread (ThreadTree T) {
                pre = NULL;//pre初始为NULL
                if(T != NULL) {//非空树才能线索化
                    InThread (T);//中序线索化二叉树
                    if(pre -> rchild == NULL)
                        pre -> rtag = 1;//处理遍历最后一个结点
                }
            }

            void InThread (ThreadTree T) {
                if(T){                                  //先序线索化[放在左边if块里]
                    InThread (T -> lchild);             //visit(T);
                    visit (T);                          //if(T -> ltag == 0)//lchild不是线索前驱
                    InThread (T -> rchild);             //  PreTheard (T -> lchild);
                }                                       //PreTheard (T -> rchild);
            }

            void visit (ThreadNode *q) {
                if(q -> lchild == NULL) {//左子树为空，建立前驱线索
                    q -> lchild = pre;
                    q -> ltag = 1;
                }
                if(pre != NULL && pre -> rchild == NULL) {
                    pre -> rchild = q;//建立前驱结点的后继线索
                    pre -> rtag = 1;
                }
                pre = q;
            }
        
        · 线索二叉树寻找前驱后继
            · 中序线索二叉树
                · 寻找后继
                ①若p -> rtag == 1,则 next = p -> rchild
                ②若p -> rtag == 0,p必有右孩子，next = p的右子树中最左下结点
                //找到以p为根的子树中，第一个被中序遍历的结点
                ThreadNode *Firstnode (ThreadNode *p) {
                    //循环找到左下结点(不一定是叶子结点)
                    while (p -> ltag == 0) p = p -> lchild;
                    return p;
                }
                //在中序线索二叉树中找到结点p的后继结点
                ThreadNode *Nextnode (ThreadNode *p) {
                    //右子树中的最左下结点
                    if (p -> rtag == 0) return Firstnode (p -> rchild);
                    else return p -> rchild;//rtag==1直接返回后继线索
                }
                //对中序线索二叉树进行中序遍历 (利用线索实现的非递归算法)
                void InOrder (ThreadTree T) {
                    for(ThreadNode *p = Firstnode(T); p; p = Nextnode(p))
                        visit (p);
                }

                · 寻找前驱//同上先找lastnode，找前驱，可以实现逆向中序遍历
                ①若p -> ltag == 1,则 next = p -> lchild
                ②若p -> ltag == 0,p必有左孩子，next = p的左子树中最右下结点

            · 先序线索二叉树
                · 寻找后继
                · 寻找后继

            · 后序线索二叉树
                · 寻找后继
                · 寻找前驱
    <2> 二叉排序树//进行中序遍历可以得到一个递增的有序序列
     · 定义：又称二叉查找树(BST Binary Search Tree)
      --左子树上所有结点的关键字均小于根节点的关键字
      --右子树上所有结点的关键字均大于根节点的关键字
      --左子树和右子树分别又各是一颗二叉排序树
     
     · 二叉排序树的查找--小于根节点往左找，大于往右找
        BSTNode *BST_Search (BSTree T, int key) {//非递归
            while (T && key != T -> key) {
                if(key < T -> key) T = T -> lchild;
                else T = T -> rchild;
            }
            return T;
        }

        BSTNode *BSTSearch (BSTree T, int key) {
            if(T == NULL)
                return NULL;    //查找失败
            if(key == T -> key)
                return T;       //查找成功
            else if(key < T -> key)
                return BSTSearch (T -> lchild, key);//在左子树中找
            else
                return BSTSearch (T -> rchild, key);//在右子树中找
        }

     · 二叉排序树的插入--小于根节点插入左子树，大于插入右子树
        int BST_Insert (BSTree &T, int k) {//递归实现
            if(T == NULL) {
                T = (BSTree) malloc (sizeof(BSTNode));
                T -> key = k;
                T -> lchild = T -> rchild = NULL;
                return 1;//插入成功
            }
            else if(k == T -> key)
                return 0;//存在相同的结点，插入失败
            else if(k < T -> key)
                return BST_Insert (T -> lchild, k);
            else
                return BST_Insert (T -> rchild, k);
        }
     
     · 二叉排序树的构造//按照 str[]中的关键字序列建立二叉排序树
        void Creat_BST (BSTNode &T, int str[], int n) {
            T = NULL;           //初始时T为空树
            int i = 0;
            while (i < n) {
                BST_Insert (T, str[i]);
                i++;
            }
        }//不同的关键字序列可能得到同款二叉排序树

     · 二叉排序树的删除
        --叶子结点直接删除就好
        --只有左子树或者只有右子树，用其子树代替该结点即可
        --既有左子树也有右子树
         //在右子树中找到最小的结点代替即可[右子树中序遍历第一个结点/右子树最左下结点],再删除最小结点即可
         //在左子树中找到最大的结点代替即可[左子树中序遍历最后一个结点/左子树最右下结点],再删除最大结点即可
            ①直接后继实现 
            ②直接前驱实现
     · 查找效率分析
        --最差效率：O(h)
        --平均查找长度 ASL (average search length)
        --查找失败的平均查找长度(需补充失败结点)
    <3> 平衡二叉树--AVL树--树上任一结点的左子树和右子树的高度之差不超过1
     --结点的平衡因子 = 左子树高 - 右子树高【-1/0/1】
     typedef struct AVLNode {
        int key;        //数据域
        int balance;    //平衡因子
        struct AVLNode *lchild, *rchild;
     } AVLNode, *AVLTree;
     
    <4> 哈夫曼树

——————————————————————————————————————————————————————————————————————————————————————————

五、树的储存结构
    <1> 双亲表示法(顺序存储)
    <2> 孩子表示法(顺序+链式存储)
    <3> 孩子兄弟表示法(链式存储)--多用[树和二叉树的转换：左边孩子右边都是兄弟]
    森林和二叉树的转换--先把树都转化为二叉树，根节点都为兄弟，都连在右边即可
    二叉树-->按右边节点转化为几棵树(森林)

——————————————————————————————————————————————————————————————————————————————————————————

六、树、森林的遍历
    <1> 树的遍历
        · 树的先根遍历：若树非空，先访问根节点，再依次对每棵子树进行先根遍历
         void PreOrder (TreeNode *R) {//深度优先遍历
            if(R) {
                visit (R); //访问根节点
                while (R还有下一个子树T)
                    PreOrder(T); //先根遍历下一棵子树
            }
         }
        
        · 树的后根遍历：若树非空，先依此对每棵子树进行后根遍历，最后再访问根节点
         void PostOrder (TreeNode *R) {//深度优先遍历
            if(R) {
                while (R还有下一个子树T)
                    PostOrder (T); //后根遍历下一棵子树
                visit (R); //访问根节点
            }
         }
        
        · 树的层次遍历(用队列实现)[广度优先遍历]
         ①若树非空，则根节点入队
         ②若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队
         ③重复②直到队列为空

    <2> 森林的遍历
        1) 先序遍历森林
         ·若森林非空，则按如下规则进行遍历：[效果等于依次对各个树先序遍历序列相连]
         [也等于先转化为二叉树再先序遍历的序列]
         ①访问森林中第一棵树的根节点
         ②先序遍历第一棵树中根节点的子树森林
         ③先序遍历除去第一棵树之后剩余的树构成的森林

        2) 中序遍历森林//效果等同于依次对各个树进行后根遍历[也等于先转化为二叉树再中序遍历的序列]

——————————————————————————————————————————————————————————————————————————————————————————